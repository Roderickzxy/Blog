---
layout: post
title:  "直播问答api与存储设计"
crawlertitle: "后台获取不到post的数据"
summary: "类似冲顶大会那种直播问答的接口以及存储设计演变"
date:   2018-01-27 14:15:56 +0700
cataname: 积累，等待，蜕变
category: tech/2018-01-27
tags: 'tech-程序功能设计过程'
author: Roderick
---
此次的功能需求是要完成一个类似冲顶大会的直播问答，直播的同时在聊天室发送题目给观众抢答，在有限时间内（10秒）答对可以进下一题，答错的话下一题只能观战。  

[![attache1]({{ site.article_attachedimages | relative_url }}/tech/article6-attache1.jpg)]({{ site.article_attachedimages | relative_url }}/article6-attache1.jpg)  
我负责的功能是设计获取题目，提交答案，返回统计结果的接口以及相关存储设计。  

整个业务实现的架构如下：  
[![attache2]({{ site.article_attachedimages | relative_url }}/tech/article6-attache2.png)]({{ site.article_attachedimages | relative_url }}/article6-attache2.png)   
而API的设计经历了几个版本：  
首先存储使用redis来存储。不需要使用数据库。  
### 版本1： ###
在直播助手开始答题游戏之前，就从数据库将所有题目详情保存进缓存中，具体内容保存为： `ITEM_ID_INDEX_DETAIL` ，value为json题目内容。  
正确答案保存为： `ITEM_ID_INDEX_COR` ，value为选项。  
设定第一题的标志： `ITEM_ID_INDEX_ISFIRST` ，value为1。 
 
（1）学员端请求题目：（ID为套题id，INDEX为题序）    
因此直接从缓存中获取题目，并且创建开始计时时间 `ITEM_ID_INDEX_COUNTER`，设定过期时间为10秒。  

（2）学员端提交答案：  
先判断 `ITEM_ID_INDEX_COUNTER` 的值是否存在。然后再根据 `ITEM_ID_INDEX_[userid]` 判断之前是否已经提交过。
a.根据 `ITEM_ID_INDEX_ISFIRST` 判断是否为第一题  
b.否则判断 `ITEM_ID_（INDEX-1）_[correct]` 有没有此用户id，correct为上一题的正确选项。  
上面通过则将用户id保存到key为 `ITEM_ID_INDEX_[option]` 的set集合中，option为具体的选项。同时设置 `ITEM_ID_INDEX_[userid]` 的值为任意值。上面逻辑不通过则不做任何操作。  

（3）教师获取答案：  
通过keys找所有选项的set， `ITEM_ID_INDEX_[option]` 获取每个选项的set的答题人数，查询正确答案选项 `ITEM_ID_INDEX_[correct]` ，再判断userid在不在set里面，将结果返回。

> 通过第一轮开会，版本1需要的改进：  
> 1. 请求题目应该由教师端做，才能统一时间限定，减少并发度   
> 2. 判断第一题直接通过index的值判断即可  
> 3. 使用redis绝对不能使用keys

### 版本2： ###
在直播助手开始答题游戏之前，就从数据库将所有题目详情保存进缓存中，具体内容保存为： `ITEM_ID_INDEX_DETAIL` ，value为json题目内容。  
正确答案保存为： `ITEM_ID_INDEX_COR` ，value为选项。

（1）教师请求题目：  
从`ITEM_ID_INDEX_DETAIL`获取题目，设定`ITEM_ID_INDEX_COUNTER`的过期时间为10秒，题目发送给学生。

（2）学员提交答案：  
先判断 `ITEM_ID_INDEX_COUNTER` 的值是否存在。然后再根据 `ITEM_ID_INDEX_[userid]` 判断之前是否已经提交过。
a.通过index，判断是否为第一题  
b.否则判断 `ITEM_ID_（INDEX-1）_[correct]` 有没有此用户id，correct为上一题的正确选项。  
上面通过则将用户id保存到key为 `ITEM_ID_INDEX_[option]` 的set集合中，option为具体的选项。同时设置 `ITEM_ID_INDEX_[userid]` 的值为任意值。上面逻辑不通过则不做任何操作。

（3）教师获取答案：  
通过keys找所有选项的set， `ITEM_ID_INDEX_[option]` 获取每个选项的set的答题人数，查询正确答案选项 `ITEM_ID_INDEX_[correct]` ，再判断userid在不在set里面，将结果返回。

> 通过第二轮开会，版本2需要的改进：  
> 1. 每次提交答案，高并发量对同一个set操作，会引起性能瓶颈，需要将压力分散出来。   

### 版本3 ###
在直播助手开始答题游戏之前，就从数据库将所有题目详情保存进缓存中，具体内容保存为： `ITEM_ID_INDEX_DETAIL` ，value为json题目内容。  
正确答案保存为： `ITEM_ID_INDEX_COR` ，value为选项。

（1）教师请求题目：  
从 `ITEM_ID_INDEX_DETAIL` 获取题目，设定 `ITEM_ID_INDEX_COUNTER` 的过期时间为10秒，题目发送给学生。

（2）学员提交答案：
直接将答案与提交时间保存到redis里：  
key为 `ITEM_ID_INDEX_[userid]`，value为hash值：field：option和timestamp。

（3）教师获取答案：
a.第一题，从 `ITEM_INIT_USER` （登录的时候需要初始化的数据）的set里获取用户id  
b.之后的题目，从上一题的 `ITEM_ID_(INDEX-1)_[option]` 的set里获取所有用户id  
遍历所有用户id，将 `ITEM_ID_INDEX_[userid]` 获取option，然后将用户id sadd到 `ITEM_ID_INDEX_[option]` 中（需要判断`ITEM_ID_INDEX_[userid]` 的timestamp对比 `ITEM_ID_INDEX_COUNTER` 有没有超时），统计每个set的人数，并且返回结果。

> 通过第三轮开会，版本2需要的改进：  
> 1. 需要加入复活卡功能

### 版本4 ###
在直播助手开始答题游戏之前，就从数据库将所有题目详情保存进缓存中，具体内容保存为： ITEM_ID_INDEX_DETAIL ，value为json题目内容。
正确答案保存为： ITEM_ID_INDEX_COR ，value为选项。

（1）登录接口  
将userid加入 `ITEM_INIT_USER` ,获取复活卡数量，假如>0，则加入 `ITEM_REVIVA_USER` 的set中。

（2）教师请求题目：  
从 `ITEM_ID_INDEX_DETAIL` 获取题目，设定 `ITEM_ID_INDEX_COUNTER` 的过期时间为10秒，题目发送给学生。

（3）学员提交答案：
直接将答案与提交时间保存到redis里：  
key为 `ITEM_ID_INDEX_[userid]`，value为hash值：field：option和timestamp。

（4）教师获取答案：
a.第一题，从 `ITEM_INIT_USER` （登录的时候需要初始化的数据）的set里获取用户id  
b.之后的题目，从上一题的 `ITEM_ID_(INDEX-1)_[option]` 的set里获取所有用户id  
遍历所有用户id，将 `ITEM_ID_INDEX_[userid]` 获取option，然后将用户id sadd到 `ITEM_ID_INDEX_[option]` 中（需要判断`ITEM_ID_INDEX_[userid]` 的timestamp对比 `ITEM_ID_INDEX_COUNTER` 有没有超时），遍历 `ITEM_REVIVA_USER` 的userid，判断是否在正确答案的 `ITEM_ID_INDEX_[option]` 有没有包含此userid，没有的话，需要加入此用户，再将其他set删除此用户，再将userid从 `ITEM_REVIVA_USER` 删除，统计每个set的人数，并且返回结果。

现在想想，开头的设计确实挺烂的，最后在各位大佬的提议帮助下，改进了很多东西，自己还是需要多实战应对这些问题，积累更多的经验才行。