---
layout: post
title:  "springboot-配置文件的使用"
crawlertitle: "springboot很智能，maven构建一下就可以用了"
summary: "简单介绍springboot框架的搭建"
date:   2018-05-28 11:27:56 +0700
cataname: 积累，等待，蜕变
category: tech/2018-05-28
tags: 'tech-Spring框架'
author: Roderick
---

配置文件格式可以为properties和yml，这里采用yml的格式，1是结构更清晰，2是idea更加支持格式
先看一段配置文件的代码：  
{% highlight shell %}
#########################################################
# default config
#########################################################
# Miniprogram Configuration
miniprogram:
    profiles:
        - name: polyv
           appid: xxxxxxxxxxxxxxxxxxxxx
           secret: 111111111111111111
        - name: funde
           appid: zzzzzzzzzzzzzzzzzzzzz
           secret: 222222222222222222
        - name: fundetest
           appid: yyyyyyyyyyyyyyyyyyyy
           secret: 333333333333333333

spring:
    profiles:
        active: dev
---
#########################################################
# local dev env
#########################################################
spring:
    profiles: dev
    redis:
        host: 192.168.85.133
        port: 6379

server:
    port: 8080

---
#########################################################
# sit env
#########################################################
spring:
    profiles: sit
    redis:
        host: test.redis.net
        port: 6379

server:
    port: 8081

---
#########################################################
# production env
#########################################################
spring:
    profiles: product
    redis:
        host: pro.redis.net
        port: 6379
        password: AsdQwe123

server:
    port: 8080
{% endhighlight %}   

上面的配置文件，主要是分成四部分（跟---作为profile的划分线）：  
使用spring:profiles:active表示使用特定的profile  
第一部分，默认配置：  
所有环境都可以使用这部分里的配置。配置的java类可以如下：  
{% highlight shell %}
package com.live.config;

import java.io.Serializable;
import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.ServletRequestUtils;

import com.fasterxml.jackson.databind.ser.Serializers;

/**
* @Author: xinyue.zheng
* @Description: 小程序配置
* @Date: Created in 14:59 2018/5/3
* @Modified By:
*/
@Component
@ConfigurationProperties(prefix="miniprogram")
public class MiniProgramConfig {
    
    private List<Map<String, String>> profiles;
    
    public List<Map<String, String>> getProfiles() {
        return profiles;
    }
    
    public void setProfiles(List<Map<String, String>> profiles) {
        this.profiles = profiles;
    }
}
{% endhighlight %}   
配置文件的一个配置是以miniprogram作为根节点的，因此配置的java类里，直接用@ConfigurationProperties(prefix="miniprogram")就可以绑定这个配置下的所有变量。    
类下有个profiles字段，也映射到配置文件的profiles下的数组（数组用-作为元素划分）。    
再看到另外三个部分，有个配置是spring:profiles:XX 这个是表示此---区域内，是XX类型的配置。我把redis的配置写在spring的根节点下，是因为我的redis操作是使用了springboot starter集成的操作redis的功能。  
配置也非常简单，只需要把spring:redis下的相关配置写好就行了。然后就可以在java里使用注入的方式，使用RedisTemplate和StringRedisTemplate的工具去操作redis，假如想要存储序列化对象，可以参考此文章：http://blog.didispace.com/springbootredis/?utm_source=tuicool&utm_medium=referral  

运行时选择profiles：  
springboot运行方式一种是使用内置服务器，一种是打包成war包来跑：    
	1. 
nohup mvn spring-boot:run -Dspring.profiles.active=sit > ../test.log 2>&1 &  
	2. 
mvn package  


第一种可指定对应的profile配置运行。第二种呢？  

maven 编译打包只能通过pom文件来决定使用的配置选项，所以这里可以在pom文件使用profile的配置  
{% highlight xml %}  
<profiles>
    <profile>
        <id>dev</id>
        <properties>
            <env>dev</env>
        </properties>
    </profile>
    <profile>
        <id>sit</id>
        <properties>
            <env>sit</env>
        </properties>
    </profile>
    <profile>
        <id>product</id>
        <properties>
            <env>product</env>
        </properties>
    </profile>
</profiles>

<build>
    <pluginManagement>
        <plugins>
            <plugin>
                <artifactId>maven-resources-plugin</artifactId>
                <configuration>
                    <encoding>utf-8</encoding>
                    <useDefaultDelimiters>true</useDefaultDelimiters>
                </configuration>
            </plugin>
        </plugins>
    </pluginManagement>
</build>  
{% endhighlight %}

然后在yml上使用@env@的参数：  
{% highlight shell %}  
spring:
    profiles:
        active: @env@
{% endhighlight %}  

打包的时候指定profile： mvn clean package -P dev
