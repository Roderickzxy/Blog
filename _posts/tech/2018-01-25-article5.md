---
layout: post
title:  "Jmeter请求post，后台一直获取不到数据"
crawlertitle: "后台获取不到post的数据"
summary: "http请求post传递参数，后台获取不到数据的相关问题"
date:   2018-01-25 12:29:56 +0700
cataname: 积累，等待，蜕变
category: tech/2018-01-23
tags: 'tech-web开发遇到的问题'
author: Roderick
---
这是之前开发遇到的一个问题，今天也记录一下吧。  
首先问题是这样的，就是我在用Jmeter测试我写的api的时候，发现post请求过去，后台一直没拿到参数值，我Jmeter的参数如下：

[![attache1]({{ site.article_attachedimages | relative_url }}/tech/article5-attache1.png)]({{ site.article_attachedimages | relative_url }}/article5-attache1.png)  
后台代码我用RequestServletUtils.getStringParameter的方式来获取传过来的值，但是一直获取不到，我使用了http信息头：Content-Type=applcation/json也没用。  

### 原因： ###  
在servlet规范3.1.1节里，对POST数据何时会被当做parameters有描述：  
> 1. The request is an HTTP or HTTPS request.  
> 2. The HTTP method is POST.  
> 3. The content type is application/x-www-form-urlencoded.  
> 4. The servlet has made an initial call of any of the getParameter family of methods on the request object.  
> 
> If the conditions are met, post form data will no longer be available for reading directly from the request object’s input stream.

所以对于http post请求，tomcat服务器只接受application/x-www-form-urlencoded形式的请求来读取request body中内容，并放于parameter中，而且body中的内容是key=value&key=value的形式。  
再看看tomcat的HttpServletRequest的代码：
{% highlight java %}
	protectedvoid parseParameters() {   
	   //省略部分代码......  
	   parameters.handleQueryParameters();// 这里是处理url中的参数   
	   //省略部分代码......   
	   if ("multipart/form-data".equals(contentType)) { // 这里是处理文件上传请求   
	        parseParts();   
	        success = true;   
	        return;   
	   }   
	
	   if(!("application/x-www-form-urlencoded".equals(contentType))) {// 这里如果是非POST请求直接返回，不再进行处理   
	        success = true;   
	        return;   
	   }   
	   //下面的代码才是处理POST请求参数   
	   //省略部分代码......   
	   try {   
	        if (readPostBody(formData, len)!= len) { // 读取请求体数据   
	            return;   
	        }   
	   } catch (IOException e) {   
	        // Client disconnect   
	        if(context.getLogger().isDebugEnabled()) {   
	            context.getLogger().debug(   
	                    sm.getString("coyoteRequest.parseParameters"),e);   
	        }   
	        return;   
	   }   
	   parameters.processParameters(formData, 0, len); // 处理POST请求参数，把它放到requestparameter map中（即request.getParameterMap获取到的Map，request.getParameter(name)也是从这个Map中获取的） 
	   // 省略部分代码......   
	}   
    
   protected int readPostBody(byte body[], int len)  
       throws IOException {   
    
       int offset = 0;   
       do {   
           int inputLen = getStream().read(body, offset, len - offset);   
           if (inputLen <= 0) {   
                return offset;   
           }   
           offset += inputLen;   
       } while ((len - offset) > 0);   
       return len;   
    }   
{% endhighlight %}  
可以看到代码里对`application/x-www-form-urlencoded`和`multipart/form-data`做了特殊处理，其他的contenttype没有，所以只有这两种post请求，后台才能通过quest.getParameter的方式获取到参数。后者一般都是用于上传文件的时候所用。前者在传参的时候会把参数放于form data中，后者传参会把参数放于payload中。（两者区别后面会再研究）  

### 结论1： ###
当我想post参数过去后台，我需要设定好content-type为application/x-www-form-urlencoded，然后将参数以key=value&key=value的形式发送出去。  
相信有些人用过jquery的ajax，ajax用post默认是application/x-www-form-urlencoded的，请求的代码可以这么写：  
{% highlight javascript %}
 $.ajax({  
    url: 'http://localhost:8080/rate/api-limit',  
    type: 'POST',  
    data: {ptime:111111},  
    success:function(data,status){  
        console.log(data);  
    }  
 });  
{% endhighlight %}  
然后就有疑问，那这里不是将数据以json格式发的吗，为毛可以发成功，不是要key=value形式吗，然后我用浏览器的开发者窗口监控了一下，发现其实请求最后发出去的结果如下：  
[![attache2]({{ site.article_attachedimages | relative_url }}/tech/article5-attache2.png)]({{ site.article_attachedimages | relative_url }}/article5-attache2.png)  
点击view source后：
[![attache3]({{ site.article_attachedimages | relative_url }}/tech/article5-attache3.png)]({{ site.article_attachedimages | relative_url }}/article5-attache3.png)  
可以看到其实发送的参数格式依然是key=value。所以这里我大胆猜想了下，当content-type为application/x-www-form-urlencoded的时候，jquery在发请求之前会对data的内容做了解析，转为key=value的格式。所以这里当content-type为application/x-www-form-urlencoded的时候，data必须要为json的格式！假如你试用了`JSON.stringify({ptime:11111})`传递，监控到的结果会是
[![attache4]({{ site.article_attachedimages | relative_url }}/tech/article5-attache4.png)]({{ site.article_attachedimages | relative_url }}/article5-attache4.png)   
也就是说{ptime:11111}被当成一个key来解析。 
 
### 结论2： ###
我们是没办法做到，前端传一整个json的数据，然后后台直接用实体类的变量来接收的。  
假如我们真心想这么干，那没关系，我们可以换种思路，把整个json字符串用json工具来转成实体类变量。  
实现逻辑：  
我们传递一个json字符串，后台获取到字符串后转换。但是之前不是说过吗，这样传，request.getParameter拿不到东西啊，没关系，我们用最原始的方式，从输入流读取：`request.getReader().readLine()`,这样就拿到了整个json字符串，再用工具来转。注意，需要把content-type换成其他类型，这样数据会以payload形式发送。   
ajax代码：  
{% highlight javascript %}
 $.ajax({  
    url: 'http://localhost:8080/rate/api-limit',  
    type: 'POST',  
    contentType: 'application/json',
    data: JSON.stringify({ptime:11111}),  
    success:function(data,status){  
        console.log(data);  
    }  
 });  
{% endhighlight %}  